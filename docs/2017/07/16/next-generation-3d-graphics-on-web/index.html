<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Next-generation 3D Graphics on the Web | W3GL</title>
  <meta name="description" content="The Developer Community for Web Graphics Language" />
  <meta name="keywords" content="w3c,webgl,webgl2,webgpu,webgraphics,canvas,3d,web3d,frontend,glsl,opengl,shaderlanguage,metalshaderlanguage" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/images/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="W3GL">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Apple’s WebKit team today proposed a new Community Group at the W3C to discuss the future of 3D graphics on the Web, and to develop a standard API that exposes modern GPU features including low-level">
<meta name="keywords" content="转载">
<meta property="og:type" content="article">
<meta property="og:title" content="Next-generation 3D Graphics on the Web">
<meta property="og:url" content="http://w3gl.org/2017/07/16/next-generation-3d-graphics-on-web/index.html">
<meta property="og:site_name" content="W3GL">
<meta property="og:description" content="Apple’s WebKit team today proposed a new Community Group at the W3C to discuss the future of 3D graphics on the Web, and to develop a standard API that exposes modern GPU features including low-level">
<meta property="og:image" content="http://w3gl.org/images/next-generation.jpg">
<meta property="og:updated_time" content="2017-07-16T13:57:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Next-generation 3D Graphics on the Web">
<meta name="twitter:description" content="Apple’s WebKit team today proposed a new Community Group at the W3C to discuss the future of 3D graphics on the Web, and to develop a standard API that exposes modern GPU features including low-level">
<meta name="twitter:image" content="http://w3gl.org/images/next-generation.jpg">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				W3GL
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-next-generation-3d-graphics-on-web"
  class="post white-box article-type-post"
  itemscope itemprop="blogPost">
	<section class='meta'>
	<h2 class="title">
  	<a href="/2017/07/16/next-generation-3d-graphics-on-web/">
    	Next-generation 3D Graphics on the Web
    </a>
  </h2>
	
	<a href="https://webkit.org/blog/7380/next-generation-3d-graphics-on-the-web/" class="original">阅读原文</a>
	
	<time>
	  7月 16, 2017
	</time>
	
    
    <div class='cats'>
        <a href="/categories/WebGPU/">WebGPU</a>
    </div>

	</section>
	
		<section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#First-a-Little-History"><span class="toc-number">1.</span> <span class="toc-text">First, a Little History</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What’s-Next"><span class="toc-number">2.</span> <span class="toc-text">What’s Next?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebKit’s-Initial-API-Proposal"><span class="toc-number">3.</span> <span class="toc-text">WebKit’s Initial API Proposal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Getting-a-Rendering-Context-and-Rendering-Pipeline"><span class="toc-number">3.1.</span> <span class="toc-text">Getting a Rendering Context and Rendering Pipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffers"><span class="toc-number">3.2.</span> <span class="toc-text">Buffers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Drawing"><span class="toc-number">3.3.</span> <span class="toc-text">Drawing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#An-Open-Invitation"><span class="toc-number">4.</span> <span class="toc-text">An Open Invitation</span></a></li></ol></section>
	
	<section class="article typo">
  	<div class="article-entry" itemprop="articleBody">
    	<p><img src="/images/next-generation.jpg" alt="the next generation"><br>Apple’s WebKit team today proposed a new Community Group at the W3C to discuss the future of 3D graphics on the Web, and to develop a standard API that exposes modern GPU features including low-level graphics and general purpose computation. W3C Community Groups allow all to freely participate, and we invite browser engineers, GPU hardware vendors, software developers and the Web community to join us.<br><a id="more"></a></p>
<p>To kick off the discussion, we’re sharing an API proposal, and a prototype of that API for the WebKit Open Source project. We hope this is a useful starting point, and look forward to seeing the API evolve as discussions proceed in the Community Group.</p>
<p><strong>UPDATE</strong>: There is now a prototype implementation and demos of WebGPU.</p>
<p>Let’s cover the details of how we got to this point, and how this new group relates to existing Web graphics APIs such as WebGL.</p>
<h2 id="First-a-Little-History"><a href="#First-a-Little-History" class="headerlink" title="First, a Little History"></a>First, a Little History</h2><p>There was a time where the standards-based technologies for the Web produced pages with static content, and the only graphics were embedded images. Before long, the Web started adding more features that developers could access via JavaScript. Eventually, there was enough demand for a fully programmable graphics API, so that scripts could create images on the fly. Thus the <code>canvas</code> element and its associated 2D rendering API were born inside WebKit, quickly spread to other browser engines, and standardized soon afterward.</p>
<p>Over time, the type of applications and content that people were developing for the Web became more ambitious, and began running into limitations of the platform. One example is gaming, where performance and visual quality are essential. There was demand for games in browsers, but most games were using APIs that provided 3D graphics using the power of Graphics Processing Units (GPUs). Mozilla and Opera showed some experiments that exposed a 3D rendering context from the <code>canvas</code> element, and they were so compelling that the community decided to gather to standardize something that everyone could implement.</p>
<p>All the browser engines collaborated to create WebGL, the standard for rendering 3D graphics on the Web. It was based on OpenGL ES, a cross-platform API for graphics targeted at embedded systems. This was the right starting place, because it made it possible to implement the same API in all browsers easily, especially since most browser engines were running on systems that had support for OpenGL. And even when the system didn’t directly support OpenGL, the API sat at a high enough level of abstraction for projects like ANGLE to emulate it on top of other technologies. As OpenGL evolved, WebGL could follow.</p>
<p>WebGL has unleashed the power of graphics processors to developers on an open platform, and all major browsers support WebGL 1, allowing console-quality games to be built for the Web, and communities like three.js to flourish. Since then, the standard has evolved to WebGL 2 and, again, all major browser engines, including WebKit, are committed to supporting it.</p>
<h2 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next?"></a>What’s Next?</h2><p>Meanwhile, GPU technology has improved and new software APIs have been created to better reflect the designs of modern GPUs. These new APIs exist at a lower level of abstraction and, due to their reduced overhead, generally offer better performance than OpenGL. The major platform technologies in this space are Direct3D 12 from Microsoft, Metal from Apple, and Vulkan from the Khronos Group. While these technologies have similar design concepts, unfortunately none are available across all platforms.</p>
<p>So what does this mean for the Web? These new technologies are clearly the next evolutionary step for content that can benefit from the power of the GPU. The success of the web platform requires defining a common standard that allows for multiple implementations, but here we have several graphics APIs that have nuanced architectural differences. In order to expose a modern, low-level technology that can accelerate graphics and computation, we need to design an API that can be implemented on top of many systems, including those mentioned above. With a broader landscape of graphics technologies, following one specific API like OpenGL is no longer possible.</p>
<p>Instead we need to evaluate and design a new web standard that provides a core set of required features, an API that can be implemented on a mix of platforms with different system graphics technologies, and the security and safety required to be exposed to the Web.</p>
<p>We also need to consider how GPUs can be used outside of the context of graphics and how the new standard can work in concert with other web technologies. The standard should expose the general-purpose computational functionality of modern GPUs. Its design should fit with established patterns of the Web, to make it easy for developers to adopt the technology. It needs to be able to work well with other critical emerging web standards like WebAssembly and WebVR. And most importantly, the standard should be developed in the open, allowing both industry experts and the broader web community to participate.</p>
<p>The W3C provides the Community Group platform for exactly this situation. The “GPU for the Web” Community Group is now open for membership.</p>
<h2 id="WebKit’s-Initial-API-Proposal"><a href="#WebKit’s-Initial-API-Proposal" class="headerlink" title="WebKit’s Initial API Proposal"></a>WebKit’s Initial API Proposal</h2><p>We anticipated the situation of next-generation graphics APIs a few years ago and started prototyping in WebKit, to validate that we could expose a very low-level GPU API to the Web, and still get worthwhile performance improvements. Our results were very encouraging, so we are sharing the prototype with the W3C Community Group. We will also start landing code in WebKit soon, so that you can try it out for yourself. We don’t expect this to become the actual API that ends up in the standard, and maybe not even the one that the Community Group decides to start with, but we think there is a lot of value in working code. Other browser engines have made their own similar prototypes. It will be exciting to collaborate with the community and come up with a great new technology for graphics.</p>
<p>Let’s take a look at our experiment in detail, which we call “WebGPU”.</p>
<h3 id="Getting-a-Rendering-Context-and-Rendering-Pipeline"><a href="#Getting-a-Rendering-Context-and-Rendering-Pipeline" class="headerlink" title="Getting a Rendering Context and Rendering Pipeline"></a>Getting a Rendering Context and Rendering Pipeline</h3><p>The interface to WebGPU is, as expected, via the <code>canvas</code> element.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">"canvas"</span>);</div><div class="line"><span class="keyword">let</span> gpu = canvas.getContext(<span class="string">"webgpu"</span>);</div></pre></td></tr></table></figure>
<p>WebGPU is much more object-oriented than WebGL. In fact, that is where some of the efficiencies come from. Rather than setting up state before each draw operation, WebGPU allows you to create and store objects that represent state, along with objects that can process a set of commands. This way we can do some validation up front as the states are created, reducing the work we need to perform during a drawing operation.</p>
<p>A WebGPU context exposes graphics commands and parallel compute commands. Let’s just assume we want to draw something, so we’ll be using a graphics pipeline. The most important elements in the pipeline are the shaders, which are programs that run on the GPU to process the geometric data and provide a color for each drawn pixel. Shaders are typically written in a language that is specialized for graphics.</p>
<p>Deciding on a shading language in a Web API is interesting because there are many factors to consider. We need a language that is powerful, allows programs to be easily created, can be serialized into a format that is efficient for transfer, and can be validated by the browser to make sure the shader is safe. Parts of the industry are moving to shader representations that can be generated from many source formats, sort of like an assembly language. Meanwhile, the Web has thrived on the “View Source” approach, where human readable code is valuable. We expect the discussions around the shading language to be one of the most fun parts of the standardization process, and look forward to hearing community opinions.</p>
<p>For our WebGPU prototype, we decided to defer the issue and just accept an existing language for now. Since we were building on Apple platforms we picked the Metal Shading Language. How do we load our shaders into WebGPU?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> library = gpu.createLibrary( <span class="comment">/* source code */</span> );</div><div class="line"><span class="keyword">let</span> vertexFunction = library.functionWithName(<span class="string">"vertex_main"</span>);</div><div class="line"><span class="keyword">let</span> fragmentFunction = library.functionWithName(<span class="string">"fragment_main"</span>);</div></pre></td></tr></table></figure>
<p>We ask the <code>gpu</code> object to load and compile the shader from source code, producing a <code>WebGPULibrary</code>. The shader code itself isn’t that important—imagine a very simple vertex and fragment combination. A library can hold multiple shader functions, so we extract the functions we want to use in this pipeline by name.</p>
<p>Now we can create our pipeline.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The details of the pipeline.</span></div><div class="line"><span class="keyword">let</span> pipelineDescriptor = <span class="keyword">new</span> WebGPURenderPipelineDescriptor();</div><div class="line">pipelineDescriptor.vertexFunction = vertexFunction;</div><div class="line">pipelineDescriptor.fragmentFunction = fragmentFunction;</div><div class="line">pipelineDescriptor.colorAttachments[<span class="number">0</span>].pixelFormat = <span class="string">"BGRA8Unorm"</span>;</div><div class="line"><span class="keyword">let</span> pipelineState = gpu.createRenderPipelineState(pipelineDescriptor);</div></pre></td></tr></table></figure>
<p>We get a new <code>WebGPURenderPipelineState</code> object from the context by passing in the description of what we need. In this case we say which vertex and fragment shaders we’ll use, as well as the type of image data we want.</p>
<h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><p>In order to draw something you need to provide data to the rendering pipeline using a buffer. <code>WebGPUBuffer</code> is the object that can hold such data, such as geometry coordinates, colors and normal vectors.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> vertexData = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([ <span class="comment">/* some data */</span> ]);</div><div class="line"><span class="keyword">let</span> vertexBuffer = gpu.createBuffer(vertexData);</div></pre></td></tr></table></figure>
<p>In this case we have data for each vertex we want to draw in our geometry inside a <code>Float32Array</code>, and then create a <code>WebGPUBuffer</code> from that data. We’ll use this buffer later when we issue a draw operation.</p>
<p>Vertex data such as this rarely changes, but there are data that change nearly every time a draw happens. These are called uniforms. A common example of a uniform is the current transformation matrix representing a camera position. <code>WebGPUBuffers</code> are used for uniforms too, but in this case we want to write into the buffer after we’ve created it.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Imagine "buffer" is a WebGPUBuffer that was allocated earlier.</span></div><div class="line"><span class="comment">// buffer.contents exposes an ArrayBufferView, that we then interpret</span></div><div class="line"><span class="comment">// as an array of 32-bit floating point numbers.</span></div><div class="line"><span class="keyword">let</span> uniforms = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(buffer.contents);</div><div class="line"><span class="comment">// Set the uniform of interest.</span></div><div class="line">uniforms[<span class="number">42</span>] = <span class="built_in">Math</span>.PI;</div></pre></td></tr></table></figure>
<p>One of the nice things about this is that a JavaScript developer can wrap the ArrayBufferView with a class or Proxy object with custom getters and setters, so that the external interface looks like typical JavasScript objects. The wrapper object then updates the right ranges within the underlying Array that the buffer is using.</p>
<h3 id="Drawing"><a href="#Drawing" class="headerlink" title="Drawing"></a>Drawing</h3><p>Before we can tell the WebGPU context to draw something, we need to set up some state. This includes the destination of the rendering (a <code>WebGPUTexture</code> that will eventually be shown in the <code>canvas</code> ), and a description of how that texture is initialized and used. That state is stored in a <code>WebGPURenderPassDescriptor</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Ask the context for the texture it expects the next</span></div><div class="line"><span class="comment">// frame to be drawn into.</span></div><div class="line"><span class="keyword">let</span> drawable = gpu.nextDrawable();</div><div class="line"></div><div class="line"><span class="keyword">let</span> passDescriptor = <span class="keyword">new</span> WebGPURenderPassDescriptor();</div><div class="line">passDescriptor.colorAttachments[<span class="number">0</span>].loadAction = <span class="string">"clear"</span>;</div><div class="line">passDescriptor.colorAttachments[<span class="number">0</span>].storeAction = <span class="string">"store"</span>;</div><div class="line">passDescriptor.colorAttachments[<span class="number">0</span>].clearColor = [<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">1.0</span>];</div><div class="line">passDescriptor.colorAttachments[<span class="number">0</span>].texture = drawable.texture;</div></pre></td></tr></table></figure>
<p>First we ask the WebGPU context for an object that represents the next frame that we can draw into. This is what is ultimately copied into the canvas element. After we’ve finished our drawing code, we tell WebGPU that we’re done with the drawable object so it can display the results and prepare the next frame.</p>
<p>The <code>WebGPURenderPassDescriptor</code> is initialized indicating that we won’t be reading from this texture in a draw operation (the <code>loadAction</code> is <code>clear</code>), that we will use the texture after the draw (<code>storeAction</code> is <code>store</code>), and the color it should fill the texture with.</p>
<p>Next, we create the objects we’ll need to hold the actual draw operations. A <code>WebGPUCommandQueue</code> has a set of <code>WebGPUCommandBuffers</code>. We push operations into a <code>WebGPUCommandBuffer</code> using a <code>WebGPUCommandEncoder</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> commandQueue = gpu.createCommandQueue();</div><div class="line"><span class="keyword">let</span> commandBuffer = commandQueue.createCommandBuffer();</div><div class="line"><span class="comment">// Use the descriptor we created above.</span></div><div class="line"><span class="keyword">let</span> commandEncoder = commandBuffer.createRenderCommandEncoderWithDescriptor(</div><div class="line">                        passDescriptor);</div><div class="line"><span class="comment">// Tell the encoder which state to use (i.e. shaders).</span></div><div class="line">commandEncoder.setRenderPipelineState(pipelineState);</div><div class="line"><span class="comment">// And, lastly, the encoder needs to know which buffer</span></div><div class="line"><span class="comment">// to use for the geometry.</span></div><div class="line">commandEncoder.setVertexBuffer(vertexBuffer, <span class="number">0</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>At this point we have set up a rendering pipeline with shaders, a buffer holding the geometry, a queue that we’ll submit draw operations to, and an encoder that can submit to the queue. Now we just push the actual command to draw into the encoder.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// We know our buffer has three vertices. We want to draw them</span></div><div class="line"><span class="comment">// with filled triangles.</span></div><div class="line">commandEncoder.drawPrimitives(<span class="string">"triangle"</span>, <span class="number">0</span>, <span class="number">3</span>);</div><div class="line">commandEncoder.endEncoding();</div><div class="line"><span class="comment">// All drawing commands have been submitted. Tell WebGPU to</span></div><div class="line"><span class="comment">// show/present the results in the canvas once the queue has</span></div><div class="line"><span class="comment">// been processed.</span></div><div class="line">commandBuffer.presentDrawable(drawable);</div><div class="line">commandBuffer.commit();</div></pre></td></tr></table></figure>
<p>Like most 3D graphics sample code, it feels like a lot of work in order to draw a simple shape. But it’s not a waste. An advantage of these modern APIs is that much of that code is creating objects that can be reused to draw other things. For example, often content will only need a single <code>WebGPUCommandQueue</code> instance, or can create multiple <code>WebGPURenderPipelineState</code> objects up-front for different shaders. And again, the browser can do a lot of early validation to reduce the overhead during the drawing operations.</p>
<p>Hopefully this gave you a taste of the WebGPU proposal. Even though the final API produced by the W3C Community Group may be very different, we expect a lot of the general design principles to be common.</p>
<h2 id="An-Open-Invitation"><a href="#An-Open-Invitation" class="headerlink" title="An Open Invitation"></a>An Open Invitation</h2><p>Apple’s WebKit team has proposed establishing a W3C Community Group for GPU on the Web to be the forum for this work, and today you are invited to join us in defining the next standard for GPUs. Our proposal has been received positively by our colleagues at other browser engines, GPU vendors, and framework developers. With support from the industry, we invite all with an interest or expertise in this area to join the Community Group.</p>

  	</div>
	  
	  <div class="article-tags tags">
      
        <a href="/tags/转载/">转载</a>
      
	  </div>
    
		
	
		<div class="art-item-footer">
				
				
					<span class="art-item-right">next：<a href="/2017/07/16/welcome-and-getting-started/" rel="next"  title="Web图形技术中国社区欢迎您">
						Web图形技术中国社区欢迎您
					</a><i class="icon icon-chevron-thin-right"></i></span>
				
		</div>
	
	</section>
	
</article>
<script>
	window.subData = {
		title: 'Next-generation 3D Graphics on the Web',
		tools: true
	}
</script>

      </div>
      <aside class='l_side'>
        
  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/WebGPU/"><div class='name'>WebGPU</div><div class='badget'>2</div></a></li>
    
    </ul>
    
</div>
</section>

  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://www.w3.org/community/gpu/">
            <div class='name'>W3C GPU</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="http://www.w3cplus.com/">
            <div class='name'>W3C Plus</div>
        </a></li>
    
    </ul>
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/入门/" style="font-size: 14px; color: #808080">入门</a> <a href="/tags/转载/" style="font-size: 14px; color: #808080">转载</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/w3gl" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  <div>&copy; 2017 <a href="http://w3gl.org" class="codename">w3gl.org</a>. The website powered by <a href="https://hexo.io/" target="_blank">hexo</a>.</div>
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename" target="_blank">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
